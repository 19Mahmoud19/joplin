import { SandboxContext } from '../utils/types';
import Plugin from '../Plugin';
import SandboxJoplin from './SandboxJoplin';
const builtinModules = require('builtin-modules');

let requireWhiteList_:string[] = null;

function requireWhiteList():string[] {
	if (!requireWhiteList_) {
		requireWhiteList_ = builtinModules.slice();
		requireWhiteList_.push('fs-extra');
	}
	return requireWhiteList_;
}

export default class Sandbox {

	private context: SandboxContext;
	private joplin_: SandboxJoplin;
	private consoleWrapper_:any = null;
	private :string[] = null;

	constructor(plugin: Plugin, store: any, context: SandboxContext) {
		this.context = context;
		this.joplin_ = new SandboxJoplin(plugin, store, this.context);
		this.consoleWrapper_ = this.createConsoleWrapper(plugin.id);
	}

	// Wraps console calls to allow prefixing them with "Plugin PLUGIN_ID:"
	private createConsoleWrapper(pluginId:string) {
		const wrapper:any = {};

		for (const n in console) {
			if (!console.hasOwnProperty(n)) continue;
			wrapper[n] = (...args:any[]) => {
				const newArgs = args.slice();
				newArgs.splice(0, 0, `Plugin "${pluginId}":`);
				return (console as any)[n](...newArgs);
			};
		}

		return wrapper;
	}

	get joplin(): SandboxJoplin {
		return this.joplin_;
	}

	get console(): any {
		return this.consoleWrapper_;
	}

	require(filePath:string):any {
		if (!requireWhiteList().includes(filePath)) throw new Error(`Path not allowed: ${filePath}`);
		return require(filePath);
	}

	// To get webpack to work with Node module we need to set the parameter `target: "node"`, however
	// when setting this, the code generated by webpack will try to access the `process` global variable,
	// which won't be defined in the sandbox. So here we simply forward the variable, which makes it all work.
	get process():any {
		return process;
	}

	setTimeout(fn: Function, interval: number) {
		return setTimeout(() => {
			fn();
		}, interval);
	}

	setInterval(fn: Function, interval: number) {
		return setInterval(() => {
			fn();
		}, interval);
	}

	alert(message:string) {
		return alert(message);
	}

	confirm(message:string) {
		return confirm(message);
	}

}
